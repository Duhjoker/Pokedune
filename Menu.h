#ifndef _Menu_H_
#define _Menu_H_

#include "Variables.h"
#include "Player.h"
#include "World.h"

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
#define ITEM_Spice 0
#define ITEM_Water 1
#define ITEM_Ring 2
#define ITEM_Crysknife 3
#define ITEM_Thumper 4
#define ITEM_Glowglobe 5
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
const unsigned char itemName0[] = {tft.println("Spice")};
const unsigned char itemName1[] = {tft.println("Water")};
const unsigned char itemName2[] = {tft.println("Ring")};
const unsigned char itemName3[] = {tft.println("Crysknife")};
const unsigned char itemName4[] = {tft.println("Thumper")};
const unsigned char itemName5[] = {tft.println("Glowglobe")};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////dreamer2345 post 27

struct Item {
  uint8_t ID;
  boolean Active;
  uint16_t S; /// number of objects
};

const Item items[] = {
  { 0, true, 0},
  { 0, true, 0},
  { 0, true, 0},
  { 0, true, 0},
  { 0, true, 0},
  { 0, true, 0},
};

const uint8_t MaxItem = 10;

const uint8_t MaxSlots = 10;

struct Item Enviroment[MaxItem];

struct Item Inventory[MaxSlots];
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AddInv(uint8_t Item) {
  bool Added = false;
  for (uint8_t i = 0; i <  MaxSlots; i++) {                        // for unsigned 8 equals 0, i is less than the max amount of slots increments i plus 2
    if ((Inventory[i].ID == Item) && (Inventory[i].S < MaxItem)) { // if inventoryis i id equals item and inventory slot is less than the max item amount
      Inventory[i].S++;                                        // increment the slot position
      Added = true;                // <<< Was AddInv = true;
      break;                                                   // stop operation
    }
  }

  if (!Added) {                          //<<< Was if (!AddInv) {
    for (uint8_t i = 0; i <  MaxSlots; i++) {
      if (Inventory[i].ID == 0) {
        Inventory[i].S++;
        Inventory[i].ID = Item;
        Added = true;               //<<< Was AddInv = true;
        break;
      }
    }
  }
  return;                          //<<< Was return AddInv;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////filmote post 12
#define SLOT_AVAILABLE 255
#define NO_SLOT_AVAILABLE 254

struct Slot {
  int x;
  int y;
  int w;
  int h;
  uint8_t avail;
};

const uint8_t no_of_slots = 10;

const Slot slots[no_of_slots] = {
  { 16, 48, 81, 16, SLOT_AVAILABLE},
  { 16, 64, 81, 16, SLOT_AVAILABLE},
  { 16, 80, 81, 16, SLOT_AVAILABLE},
  { 16, 96, 81, 16, SLOT_AVAILABLE},
  { 16, 112, 81, 16, SLOT_AVAILABLE},
  { 16, 128, 81, 16, SLOT_AVAILABLE},
  { 16, 144, 81, 16, SLOT_AVAILABLE},
  { 16, 160, 81, 16, SLOT_AVAILABLE},
  { 16, 176, 81, 16, SLOT_AVAILABLE},
  { 16, 192, 81, 16, SLOT_AVAILABLE},
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t getFirstAvailSlot() {

  for (uint8_t i = 0; i < no_of_slots; i++) {      ///// for unsingned 8 equals 0 i is less than the number of slot
    if (slots[i].avail == SLOT_AVAILABLE) return i;          ///// use available slot
  }

  return NO_SLOT_AVAILABLE; /////254; // Or something that signifies no slots available ..

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct CursorA
{
  int cursorA_x;
  int cursorA_y;
  int cursor_direction;
};

CursorA cursora = { 8, 31, 1};

struct CursorB
{
  int cursorB_x;
  int cursorB_y;
  int cursor_direction;
};

CursorB cursorb = { 156, 130, 1};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Menu() {
  //////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////Palette////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  palette[0] = 0;
  palette[1] = BLACK;
  palette[2] = BLUE;
  palette[3] = BROWN;
  palette[4] = DARKGREEN;
  palette[5] = GREY;
  palette[6] = PINK;
  palette[7] = RED;
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  palette[8] = BEIGE;
  palette[9] = GREEN;
  palette[a] = DARKGREY;
  palette[b] = LIGHTGREY;
  palette[c] = YELLOW;
  palette[d] = PURPLE;
  palette[e] = WHITE;
  palette[f] = ORANGE;
  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  Rect rectA {0, 0, 136, 20};
  Rect rectB {0, 20, 136, 40};
  Rect rectC {0, 60, 136, 40};
  Rect rectD {0, 100, 136, 40};
  Rect rectE {0, 140, 136, 40};
  Rect rectF {0, 180, 136, 40};
  Rect rectG {0, 220, 136, 20};
  Rect rectH {cursora.cursorA_x, cursora.cursorA_y, 16, 16};
  /////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////
  tft.writeRectNBPP(0, 0, 136, 20, 4, menul1, palette);
  tft.writeRectNBPP(0, 20, 136, 40, 4, menul2, palette);
  tft.writeRectNBPP(0, 60, 136, 40, 4, menul3, palette);
  tft.writeRectNBPP(0, 100, 136, 40, 4, menul4, palette);
  tft.writeRectNBPP(0, 140, 136, 40, 4, menul5, palette);
  tft.writeRectNBPP(0, 180, 136, 40, 4, menul6, palette);
  tft.writeRectNBPP(0, 220, 136, 20, 4, menul7, palette);
  tft.writeRectNBPP(136, 0, 184, 26, 4, menur1, palette);
  tft.writeRectNBPP(136, 26, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 42, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 58, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 74, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 90, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 106, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 122, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 138, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 154, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 170, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 186, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 202, 184, 16, 4, menur2, palette);
  tft.writeRectNBPP(136, 218, 184, 22, 4, menur3, palette);
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if (tft.Bpressed(BTN_UP)) {
    tft.writeRectNBPP(cursora.cursorA_x, cursora.cursorA_y, 32, 32, 4, cursor3, palette);
    cursora.cursor_direction = 1;
    cursora.cursorA_y -= 40;
  }
  if (cursora.cursorA_y <= 30) {
    cursora.cursorA_y = 30;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////Down///////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  if (tft.Bpressed(BTN_DOWN)) {
    tft.writeRectNBPP(cursora.cursorA_x, cursora.cursorA_y, 32, 32, 4, cursor3, palette);
    cursora.cursor_direction = 1;
    cursora.cursorA_y += 40;
  }
  if (cursora.cursorA_y >= 192) {
    cursora.cursorA_y = 192;
  }
  //////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////exit menu////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  if (tft.Bpressed(BTN_B)) {
    state = STATE_Player;
  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if (cursora.cursor_direction == 1) {
    tft.writeRectNBPP(cursora.cursorA_x, cursora.cursorA_y, 32, 32, 4, cursor3, palette);
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
     if((tft.Bpressed(BTN_B) && tft.collideRectRect( rectB.x, rectB.y, rectB.width, rectB.height, rectH.x, rectH.y, rectH.width, rectH.height)))
  {
  // do some thing
  }
  else if((tft.Bpressed(BTN_B) && tft.collideRectRect( rectC.x, rectC.y, rectC.width, rectC.height, rectH.x, rectH.y, rectH.width, rectH.height)))
  {
  // do some thing
  }
  else if((tft.Bpressed(BTN_B) && tft.collideRectRect( rectD.x, rectD.y, rectD.width, rectD.height, rectH.x, rectH.y, rectH.width, rectH.height)))
  {
  // do some thing
  }
  else if((tft.Bpressed(BTN_B) && tft.collideRectRect( rectE.x, rectE.y, rectE.width, rectE.height, rectH.x, rectH.y, rectH.width, rectH.height)))
  {
  // do some thing
  }
  else if((tft.Bpressed(BTN_B) && tft.collideRectRect( rectF.x, rectF.y, rectF.width, rectF.height, rectH.x, rectH.y, rectH.width, rectH.height)))
  {
  // do some thing
   }
   if (player.player_direction == 1){
  tft.writeRectNBPP(cursora.cursorA_x, cursora.cursorA_y,16,16,4,cursordot2,palette);
  }
  }
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////load game menu////////////////////////////////////////////////////////
void loadgame() {
  Rect rectA {172, 130, 80, 20};
  Rect rectB {172, 140, 80, 20};
  Rect rectC {cursorb.cursorB_x, cursorb.cursorB_y, 16, 16};

  tft.drawRoundRect(110, 100, 110, 40, 4, WHITE);
  tft.fillRoundRect(170, 120, 38, 38, 4, BLUE);
  tft.setCursor(172, 130);
  tft.setTextColor(WHITE);
  tft.setTextSize(2);
  tft.println("New Game");
  tft.setCursor(172, 140);
  tft.setTextColor(WHITE);
  tft.setTextSize(2);
  tft.println("Continue");

  if (tft.Bpressed(BTN_UP)) {
    tft.writeRectNBPP(cursorb.cursorB_x, cursorb.cursorB_y, 32, 32, 4, cursor3, palette);
    cursorb.cursor_direction = 1;
    cursorb.cursorB_y -= 20;
  }
  if (cursorb.cursorB_y <= 30) {
    cursorb.cursorB_y = 30;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////Down///////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  if (tft.Bpressed(BTN_DOWN)) {
    tft.writeRectNBPP(cursorb.cursorB_x, cursorb.cursorB_y, 32, 32, 4, cursor3, palette);
    cursorb.cursor_direction = 1;
    cursorb.cursorB_y += 20;
  }
  if (cursora.cursorA_y >= 192) {
    cursora.cursorA_y = 192;
  }
  //////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////exit menu////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  if ((tft.Bpressed(BTN_X) && tft.collideRectRect( rectA.x, rectA.y, rectA.width, rectA.height, rectC.x, rectC.y, rectC.width, rectC.height)))
  {
    state = STATE_Player;
  }
  else if ((tft.Bpressed(BTN_X) && tft.collideRectRect( rectB.x, rectB.y, rectB.width, rectB.height, rectC.x, rectC.y, rectC.width, rectC.height)))
  {
    // do some thing
  }

  if (cursora.cursor_direction == 1) {
    tft.writeRectNBPP(cursorb.cursorB_x, cursorb.cursorB_y, 32, 32, 4, cursor3, palette);
  }
}






#endif

